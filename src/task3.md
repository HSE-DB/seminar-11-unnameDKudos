## Задание 3

1. Создайте таблицу с большим количеством данных:
    ```sql
    CREATE TABLE test_cluster AS 
    SELECT 
        generate_series(1,1000000) as id,
        CASE WHEN random() < 0.5 THEN 'A' ELSE 'B' END as category,
        md5(random()::text) as data;
    ```

2. Создайте индекс:
    ```sql
    CREATE INDEX test_cluster_cat_idx ON test_cluster(category);
    ```

3. Измерьте производительность до кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    Bitmap Heap Scan on test_cluster  (cost=59.17..7696.73 rows=5000 width=68) (actual time=21.460..218.023 rows=500111 loops=1)
      Recheck Cond: (category = 'A'::text)
      Heap Blocks: exact=8334
      ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..57.92 rows=5000 width=0) (actual time=20.282..20.292 rows=500111 loops=1)
            Index Cond: (category = 'A'::text)
    Planning Time: 2.081 ms
    Execution Time: 233.857 ms
    ```
    
    *Объясните результат:*
    Запрос использует Bitmap Index Scan по индексу test_cluster_cat_idx для поиска всех записей с category = 'A'. Найдено 500111 записей (примерно половина от миллиона). Затем выполняется Bitmap Heap Scan для получения полных строк из таблицы. Необходимо прочитать 8334 точных блоков (exact blocks), что означает, что данные не отсортированы по категории и находятся в разных местах таблицы. Время выполнения составляет 233.857 ms.

4. Выполните кластеризацию:
    ```sql
    CLUSTER test_cluster USING test_cluster_cat_idx;
    ```
    
    *Результат:*
    ```
    CLUSTER
    ```
    
    Кластеризация успешно выполнена. Таблица test_cluster теперь физически отсортирована по индексу test_cluster_cat_idx, что означает, что все строки с одинаковым значением category находятся в последовательных блоках данных.

5. Измерьте производительность после кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    Bitmap Heap Scan on test_cluster  (cost=59.17..7668.56 rows=5000 width=68) (actual time=15.407..87.988 rows=500111 loops=1)
      Recheck Cond: (category = 'A'::text)
      Heap Blocks: exact=4168
      ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..57.92 rows=5000 width=0) (actual time=14.836..14.837 rows=500111 loops=1)
            Index Cond: (category = 'A'::text)
    Planning Time: 1.724 ms
    Execution Time: 102.434 ms
    ```
    
    *Объясните результат:*
    После кластеризации запрос работает значительно быстрее. Время выполнения уменьшилось с 233.857 ms до 102.434 ms (более чем в 2 раза). Количество необходимых блоков (Heap Blocks) сократилось с 8334 до 4168 (ровно в 2 раза), что указывает на то, что данные с category = 'A' теперь физически сосредоточены в последовательных блоках. Это значительно улучшает производительность, так как уменьшается количество операций случайного доступа к диску и увеличивается эффективность кэширования.

6. Сравните производительность до и после кластеризации:
    
    *Сравнение:*
    Кластеризация показала значительное улучшение производительности:
    
    - **Время выполнения**: Уменьшилось с 233.857 ms до 102.434 ms (улучшение в 2.28 раза)
    - **Количество блоков**: Сократилось с 8334 до 4168 блоков (ровно в 2 раза)
    - **Время планирования**: Незначительно улучшилось с 2.081 ms до 1.724 ms
    
    Основное преимущество кластеризации заключается в том, что данные с одинаковым значением категории теперь физически расположены вместе, что:
    1. Уменьшает количество блоков, которые необходимо прочитать
    2. Улучшает локальность данных и эффективность кэширования
    3. Уменьшает количество случайных обращений к диску в пользу последовательного чтения
    4. Снижает общее время выполнения запросов, которые фильтруют по категории
    
    Кластеризация особенно эффективна для таблиц, где часто выполняются запросы, возвращающие большие наборы данных с одинаковым значением колонки, по которой выполнена кластеризация.